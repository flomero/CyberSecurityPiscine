#!/usr/bin/env python3

import time as t
import typing as tp
import hashlib
import argparse
from cryptography.fernet import Fernet
from colorama import Fore, Style

BLOCK_SIZE = 64
KEY_OUTPUT_FILE = 'ft_otp.key'
KEY_KEY = b'4mrmELu5dei0I2qDHQ_-S3w5MpRC1vmtEBlwRcOdzTY='
VERBOSE = False

def sha1(message: bytes) -> bytes:
	return hashlib.sha1(message).digest()

def kxor(a: bytes, b: bytes) -> bytes:
	return bytes([x ^ y for x, y in zip(a, b)])

def hmac(key: bytes, message: bytes, func: tp.Callable[[bytes], bytes] = sha1) -> bytes:
	ipad = b'\x36' * BLOCK_SIZE
	opad = b'\x5c' * BLOCK_SIZE
	if len(key) > BLOCK_SIZE:
		key = func(key)
	if len(key) < BLOCK_SIZE:
		key += b'\x00' * (BLOCK_SIZE - len(key))
	inner = kxor(key, ipad)
	inner += message
	inner = func(inner)
	outer = kxor(key, opad)
	outer += inner
	outer = func(outer)
	return outer

def totp(key: bytes, t: float, digits: int = 6, period: int = 30) -> str:
	t = int(t // period)
	t = t.to_bytes(8, 'big')
	key_bytes = bytes.fromhex(key.decode())
	h = hmac(key_bytes, t)

	offset = h[-1] & 0xF
	code = (
		((h[offset] & 0x7F) << 24) | 
		((h[offset + 1] & 0xFF) << 16) | 
		((h[offset + 2] & 0xFF) << 8) | 
		(h[offset + 3] & 0xFF)
	) % (10 ** digits)
	
	return str(code).zfill(digits)

def encrypt_key(key: bytes) -> bytes:
	cipher = Fernet(KEY_KEY)
	return cipher.encrypt(key)

def decrypt_key(key: bytes) -> bytes:
	cipher = Fernet(KEY_KEY)
	return cipher.decrypt(key)

def is_valid_input_key(key: str) -> bool:
	if len(key) != 64:
		return False
	for c in key:
		if c not in '0123456789abcdef':
			return False
	return True

if __name__ == '__main__':
	parser = argparse.ArgumentParser(description='Generate TOTP')
	parser.add_argument('-g', type=str, help='Key', required=False)
	parser.add_argument('-k', type=str, help='Key File', required=False)
	args = parser.parse_args()
	key_path = args.g.encode() if args.g else None
	key_file = args.k.encode() if args.k else None
	if (key_path is None and key_file is None) or (key_path is not None and key_file is not None):
		print(f'{Fore.RED}Invalid arguments{Style.RESET_ALL}')
		parser.print_help()
		exit(1)
	if key_path:
		try:
			with open(key_path, 'rb') as f:
				key = f.read()
		except:
			print(f'{Fore.RED}Invalid key path{Style.RESET_ALL}')
			exit(1)
		if not is_valid_input_key(key.decode()):
			print(f'{Fore.RED}Invalid key{Style.RESET_ALL}')
			exit(1)
		with open(KEY_OUTPUT_FILE, 'wb') as f:
			f.write(encrypt_key(key))
		print(f'{Fore.GREEN}Key saved to {KEY_OUTPUT_FILE}{Style.RESET_ALL}')
	elif key_file:
		with open(key_file, 'rb') as f:
			key = f.read()
		try:
			key = decrypt_key(key)
			if not key or not is_valid_input_key(str(key, 'utf-8')):
				raise Exception()
			if VERBOSE:
				print(f'{Fore.GREEN}Key decrypted{Style.RESET_ALL}: {key}')
		except:
			print(f'{Fore.RED}Invalid key file{Style.RESET_ALL}')
			exit(1)
		print(f'{Fore.GREEN}TOTP{Style.RESET_ALL}: {totp(key, t.time())}')