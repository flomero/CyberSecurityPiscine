#!/usr/bin/env python3

import time as t
import typing as tp
import hashlib
import argparse
from cryptography.fernet import Fernet

BLOCK_SIZE = 64
KEY_OUTPUT_FILE = 'ft_otp.key'
KEY_KEY = b'4mrmELu5dei0I2qDHQ_-S3w5MpRC1vmtEBlwRcOdzTY='

def sha1(message: bytes) -> bytes:
	return hashlib.sha1(message).digest()

def kxor(a: bytes, b: bytes) -> bytes:
	return bytes([x ^ y for x, y in zip(a, b)])

def hmac(key: bytes, message: bytes, func: tp.Callable[[bytes], bytes] = sha1) -> bytes:
	ipad = b'\x36' * BLOCK_SIZE
	opad = b'\x5c' * BLOCK_SIZE
	if len(key) > BLOCK_SIZE:
		key = func(key)
	if len(key) < BLOCK_SIZE:
		key += b'\x00' * (BLOCK_SIZE - len(key))
	inner = kxor(key, ipad)
	inner += message
	inner = func(inner)
	outer = kxor(key, opad)
	outer += inner
	outer = func(outer)
	return outer

def totp(key: bytes, t: float, digits: int = 6, period: int = 30) -> str:
    t = int(t / period)  # Calculate the time step
    t = t.to_bytes(8, 'big')  # Convert time step to 8-byte big-endian
    h = hmac(key, t)  # Generate HMAC
    
    # Dynamic truncation
    offset = h[-1] & 0xF
    code = (
        ((h[offset] & 0x7F) << 24) | 
        ((h[offset + 1] & 0xFF) << 16) | 
        ((h[offset + 2] & 0xFF) << 8) | 
        (h[offset + 3] & 0xFF)
    ) % (10 ** digits)
    
    return str(code).zfill(digits)

def encrypt_key(key: bytes) -> bytes:
	cipher = Fernet(KEY_KEY)
	return cipher.encrypt(key)

def decrypt_key(key: bytes) -> bytes:
	cipher = Fernet(KEY_KEY)
	return cipher.decrypt(key)

if __name__ == '__main__':
	parser = argparse.ArgumentParser(description='Generate TOTP')
	parser.add_argument('-g', type=str, help='Key', required=False)
	parser.add_argument('-k', type=str, help='Key File', required=False)
	args = parser.parse_args()
	key = args.g.encode() if args.g else None
	key_file = args.k.encode() if args.k else None
	if (key is None and key_file is None) or (key is not None and key_file is not None):
		print('Wrong input. Please provide key OR key file')
		parser.print_help()
		exit(1)
	if key:
		with open(KEY_OUTPUT_FILE, 'wb') as f:
			f.write(encrypt_key(key))
		print('Key saved to', KEY_OUTPUT_FILE)
	elif key_file:
		with open(key_file, 'rb') as f:
			key = f.read()
		try:
			key = decrypt_key(key)
			if not key:
				raise Exception()
			print('Key:', key)
		except:
			print('Invalid key file')
			exit(1)
		print(totp(key, t.time()))